---
title: "Forecasting multiple periods (steps) ahead - recursive approach"
---

```{r set_up_python, echo=FALSE}
#|echo: FALSE

if (Sys.getenv("USERPROFILE") == "C:\\Users\\internet"){
  
  python_path = paste0("C:\\Users\\internet\\AppData\\Local",
                       "\\Programs\\Python\\Python312\\python.exe")
} else {
  
  python_path = paste0("C:\\Users\\Home\\AppData\\Local",
                       "\\Programs\\Python\\Python312\\python.exe")
}

reticulate::use_python(python_path)

```

```{python}

import numpy as np

import pandas as pd

from feature_engine.creation import CyclicalFeatures

from feature_engine.datetime import DatetimeFeatures

from feature_engine.imputation import DropMissingData

from feature_engine.selection import DropFeatures 

from feature_engine.timeseries.forecasting import (LagFeatures, WindowFeatures)

from sklearn.linear_model import Lasso

from sklearn.multioutput import MultiOutputRegressor

from sklearn.metrics import root_mean_squared_error

from sklearn.pipeline import Pipeline

import matplotlib.pyplot as plt

import os 

```

++ Here, we want to demonstrate how to forecast multiple period (step) using a recursive approach.The recursive approach entails forecasting step by step: forecasting the next step, updating the data required to produce (engineer) predictve features and than making the next forecast based on the updated data.

```{python import_data}

file_path = os.path.expanduser("~/Documents") + "\\DS_advanced_website\\data\\example_air_quality.csv"

raw_df = pd.read_csv(file_path,
                             index_col = "Date_Time")

raw_df.index = pd.to_datetime(raw_df.index)

```

## Pipeline

The following steps involve extracting essential features from the datetime index, creating lag and window-based features, and transforming cyclical features like month and hour into sinusoidal form to capture seasonality. Additionally, any missing data is handled and specific features are dropped before fitting the model. The pipeline approach is utilized to bundle these operations into a single object for convenience and reusability.

```{python define_preprocessing}

date_time_feat = DatetimeFeatures(
  variables = "index",
  features_to_extract = ["month","week","day_of_week",
                         "day_of_month","hour","weekend"]
                         )

lag_feat = LagFeatures(
  variables = ["CO_sensor","RH"],
  freq = ["1h","12h"],
  missing_values = "ignore"
)


window_feat = WindowFeatures(
  variables = ["CO_sensor","RH"],
  window = "3h",
  freq = "1h",
  missing_values = "ignore"
)


cyclical_feat = CyclicalFeatures(
  variables = ["month","hour"],
  drop_original = False
)


na_drop = DropMissingData()

drop_feat = DropFeatures(features_to_drop = ["CO_sensor","RH"])


trans_pipe = Pipeline(
  [("date_time_features",date_time_feat),
   ("lag_features",lag_feat),
   ("window_features",window_feat),
   ("periodic_features",cyclical_feat),
   ("drop_original_features",drop_feat),
   ("drop_missing_values",na_drop)
  ]
  
)


```

The pipeline defined here combines feature engineering tasks such as creating lag features, window statistics, and cyclical features, along with handling missing data and dropping unnecessary columns. This ensures that all transformations are consistently applied to both the training and testing sets, preventing leakage of future information.

```{python pipeline}

trans_pipe = Pipeline(
  [("date_time_features",date_time_feat),
   ("lag_features",lag_feat),
   ("window_features",window_feat),
   ("periodic_features",cyclical_feat),
   ("drop_original_features",drop_feat),
   ("drop_missing_values",na_drop)
  ]
  
)
del date_time_feat, lag_feat, window_feat, cyclical_feat, drop_feat,na_drop

```

## Train and test split

In time series forecasting, itâ€™s important to account for the lagged features when splitting the data into train and test sets. The test set should contain enough prior data to compute the lagged and window-based features accurately. In this case, the longest lag is 12 hours, so we need to ensure that the test set includes the first forecasting point and at least 12 hours before it. We will split the data so that the last month is allocated to the test set. The chosen split point is "2005-03-04". If we have enough data in order to be on the safe side we can completely eliminate any overlap between the train and the test set by limiting the train set to data before split point shifted by the offset range.

```{python split_train_test}

split_point = pd.Timestamp("2005-03-04")

X_train = raw_df.loc[raw_df.index < split_point]

X_test = raw_df.loc[raw_df.index >= split_point - pd.offsets.Hour(12)]

Y_train = raw_df.loc[raw_df.index < split_point,["CO_sensor", "RH"]]

Y_test = raw_df.loc[raw_df.index >= split_point - pd.offsets.Hour(12),
                   ["CO_sensor", "RH"]]


```


## Preprocess data

```{python preprocess_data}

X_train_processed = trans_pipe.fit_transform(X_train.copy())

Y_train = Y_train.loc[X_train_processed.index]

# X_test_processed = trans_pipe.fit_transform(X_test.copy())
# 
# Y_test = Y_test.loc[X_test_processed.index]

```

After preprocessing and ensuring that the features and target are properly aligned, we can train the forecasting model. Here, we use Lasso regression, a linear model that performs both variable selection and regularization to prevent overfitting. This model is suitable for time series forecasting with many features, especially when we want to avoid overly complex models that may not generalize well to unseen data.

## Prediction

++ explain the for illustration sake we will produce the first two forecast (first and second forecasting points) "manually". Then we will automate the process of producing the next forecast by updating the input data (using current forecast) and passing the updated data to the model

```{python model}

lasso_model = MultiOutputRegressor(Lasso())

lasso_model.fit(X_train_processed, Y_train)

```

### First point

```{python make_input_data_for_first_point}

first_forecast_point = pd.Timestamp("2005-03-04")

first_input_data = X_test.loc[
  (X_test.index >= first_forecast_point - pd.offsets.Hour(12)) &
  (X_test.index < first_forecast_point)
  ]
                        
forecast_row = pd.DataFrame(data = np.nan,
                            index = [first_forecast_point],
                            columns = ["CO_sensor","RH"])
                            
first_input_data = pd.concat([first_input_data.copy(),
                              forecast_row], axis = 0)

print(first_input_data)


```

```{python first_point_process_and_predict}

first_input_data_processed = trans_pipe.transform(first_input_data)

print(first_input_data.index.min(),first_input_data.index.max())

print(first_input_data_processed.index.min(),
      first_input_data_processed.index.max())
      

first_point_pred = lasso_model.predict(first_input_data_processed)

predictions_df = pd.DataFrame(data = first_point_pred,
                                index = [first_forecast_point],
                                columns = ["CO_sensor","RH"])

```



### Second point

```{python predict_second_point}

second_forecast_point = first_forecast_point + pd.offsets.Hour(1)

second_input_data = first_input_data.iloc[1:].copy()

second_input_data.loc[first_forecast_point] = first_point_pred

second_forecast_row = pd.DataFrame(data = np.nan,
                            index = [second_forecast_point],
                            columns = ["CO_sensor","RH"])

second_input_data = pd.concat([second_input_data.copy(),
                              second_forecast_row], axis = 0)                      

```


```{python second_point_process_and_predict}

second_input_data_processed = trans_pipe.transform(second_input_data)

second_point_pred = lasso_model.predict(second_input_data_processed)

predictions_df = pd.concat([predictions_df.copy(),
                            pd.DataFrame(data = second_point_pred,
                            index = [second_forecast_point],
                            columns = ["CO_sensor","RH"])])



```

```{python predictions}

print(predictions_df)

```

# Automate recursive forecast

++ explain that the main idea is to use a loop: first we will make the first forecast outside the loop and then loop through the remaining forecast horizons updatding data and producing the next forecast. In order to simplify the code we will break the task to simpler tasks:
1. Forecast the next point based on current input data, preprocessing instructions and the model
2. Update the input data by adding the current forecast

We will perform the two tasks in a loop through the entire forecast horizon range

```{python }


def forecast_next_point(input_data, model, preprocess_pipe):
  input_data_processed = preprocess_pipe.transform(input_data)
  prediction = model.predict(input_data_processed)
  return(prediction)

def update_input_data(input_data, last_prediction):
  input_data.iloc[len(input_data) - 1] = last_prediction
  input_data = input_data.iloc[1:].copy()
  next_forecast_row = pd.DataFrame(
                      data = np.nan,
                      index = [input_data.index.max() + pd.offsets.Hour(1)],
                      columns = input_data.columns.values
                      )
                      
  input_data = pd.concat([input_data.copy(), next_forecast_row], axis = 0)
  return input_data

def make_recursive_forecast(forecast_horizon,
                            initial_input_data,model, preprocess_pipe):
                              
    # Initial case
                              
    current_data = initial_input_data.copy()

    current_pred = forecast_next_point(initial_input_data,model,preprocess_pipe)
    
    predictions_df = pd.DataFrame(data = current_pred,
                                  index = [initial_input_data.index.max()],
                                  columns = initial_input_data.columns.values)
                                  
    # Loop through the remaining forecasting range                            
    
    for temp_hor in range(1, forecast_horizon):
      
      current_data = update_input_data(current_data.copy(), current_pred)
      
      current_pred = forecast_next_point(current_data, model, preprocess_pipe)
      
      predictions_df = pd.concat([predictions_df.copy(),
                                  pd.DataFrame(data = current_pred,
                                  index = [current_data.index.max()],
                                  columns = current_data.columns.values)],
                                  axis = 0)
                                  
    return predictions_df
  
  
predictions_for_24_h = make_recursive_forecast(forecast_horizon = 24,
                               initial_input_data = first_input_data,
                               model = lasso_model,
                               preprocess_pipe = trans_pipe)
                               
print(predictions_for_24_h.head())


```

```{python plot_predictions}

predictions_for_24_h["CO_sensor"].plot()

plt.show()

```

