---
title: "Forecasting pipeline"
---

```{r set_up_python, echo=FALSE}
#|echo: FALSE

if (Sys.getenv("USERPROFILE") == "C:\\Users\\internet"){
  
  python_path = paste0("C:\\Users\\internet\\AppData\\Local",
                       "\\Programs\\Python\\Python312\\python.exe")
} else {
  
  python_path = paste0("C:\\Users\\Home\\AppData\\Local",
                       "\\Programs\\Python\\Python312\\python.exe")
}

reticulate::use_python(python_path)

```

```{python}

import pandas as pd

from feature_engine.creation import CyclicalFeatures

from feature_engine.datetime import DatetimeFeatures

from feature_engine.imputation import DropMissingData

from feature_engine.selection import DropFeatures 

from feature_engine.timeseries.forecasting import (LagFeatures, WindowFeatures)

from sklearn.pipeline import Pipeline

import matplotlib.pyplot as plt
import os 

```



```{python import_data}

file_path = os.path.expanduser("~/Documents") + "\\DS_advanced_website\\data\\example_air_quality.csv"

raw_df = pd.read_csv(file_path,
                             index_col = "Date_Time")

raw_df.index = pd.to_datetime(raw_df.index)

```

++ our goal is to perform the following steps (show as itemized list):
 - Date and time features
 - Lag features
 - Window features
 - Cyclical features
 - Removing missing values

The feature engineering will be performed using the library feature_engine
The purpose is to encapsulate all the operations in one pipeline

```{python extract_date_time_features}

date_time_feat = DatetimeFeatures(
  variables = "index",
  features_to_extract = ["month","week","day_of_week",
                         "day_of_month","hour","weekend"]
                         )

processed_df = date_time_feat.fit_transform(raw_df.copy())


processed_df.head()

```

```{python extract_lag_features}

lag_feat = LagFeatures(
  variables = ["CO_sensor","RH"],
  freq = ["1h","24h"],
  missing_values = "ignore"
)

processed_df = lag_feat.fit_transform(processed_df.copy())

names_list = [name for name in processed_df.columns if "lag" in name]

processed_df[names_list].head()

```

```{python extract_window_features}

window_feat = WindowFeatures(
  variables = ["CO_sensor","RH"],
  window = "3h",
  freq = "1h",
  missing_values = "ignore"
)

processed_df = window_feat.fit_transform(processed_df.copy())

names_list = [name for name in processed_df.columns if "win" in name]

processed_df[names_list].head()

```

```{python extract_cyclical_features}

cyclical_feat = CyclicalFeatures(
  variables = ["month","hour"],
  drop_original = False
)

processed_df = cyclical_feat.fit_transform(processed_df.copy())

names_list = [name for name in processed_df.columns if "month" or "hour" in name]

processed_df[names_list].head()

```

```{python remove_missing_values}

na_drop = DropMissingData()

processed_df = na_drop.fit_transform(processed_df.copy())

```

++ explain that we are creating an explanatory variables data frame (X_mat). In order to avoid data leakage (or look ahead bias) we now need to drop the original features after we extracted all required info using feature engineering

```{python drop_original_features}

drop_feat = DropFeatures(features_to_drop = ["CO_sensor","RH"])

processed_df = drop_feat.fit_transform(processed_df.copy())

processed_df.head()

```

# Pipeline

++ packing it all into one pipeline

```{python pipeline}

trans_pipe = Pipeline(
  [("date_time_features",date_time_feat),
   ("lag_features",lag_feat),
   ("window_features",window_feat),
   ("periodic_features",cyclical_feat),
   ("drop_missing_values",na_drop),
   ("drop_original_features",drop_feat)
  ]
  
)

pipe_processed_df = trans_pipe.fit_transform(raw_df.copy())

print(f"The processed df is equal to pipe_processed_df : {pipe_processed_df.equals(processed_df)}")

```


